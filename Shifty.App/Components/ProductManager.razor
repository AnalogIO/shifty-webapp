@namespace Components
@using System.ComponentModel.DataAnnotations
@using Shifty.App.Services
@using Shifty.Api.Generated.AnalogCoreV1
@using Shifty.Api.Generated.AnalogCoreV2
@using Shared
@using LanguageExt.UnsafeValueAccess
@inject ISnackbar Snackbar
@inject IProductService ProductService

<MudPaper Elevation="15" Style="margin: 40px auto; border-radius: 5px;" MaxWidth="1200px">
    @if (_loading)
    {
        <MudContainer Style="width: 100%; display: flex;">
            <LoadingIndicator Height="400px" />
        </MudContainer>
    }
    <MudDataGrid
        T="ProductResponse"
        Items="@_products"
        EditMode="DataGridEditMode.Form"
        ReadOnly="false"
        CanceledEditingItem="@CanceledEditingItem"
        CommittedItemChanges="@CommittedItemChanges"
        EditTrigger="DataGridEditTrigger.Manual"
        RowStyleFunc="@_RowStyleFunc">
        <Columns>
            <PropertyColumn Property="x => x.Id" Title="Id" IsEditable="false"/>
            <PropertyColumn Property="x => x.IsPerk" Title="IsPerk" IsEditable="false">
                <CellTemplate>
                    @{
                        if (context.Item.IsPerk)
                        {
                            <MudIcon Style="color:gold;" Icon="@Icons.Material.Filled.Star" Title="IsPerk" />
                        }
                        else
                        {
                            <MudIcon Icon="@Icons.Material.Filled.StarOutline" Title="IsPerk" />
                        }
                    }
                </CellTemplate>
            </PropertyColumn>
            <PropertyColumn Property="x => x.Name" Title="Name" IsEditable="true"/>
            <PropertyColumn Property="x => x.Visible" Title="Visibility" IsEditable="true">
                <EditTemplate>
                    <MudSwitch
                        Label="Visible"
                        Color="Color.Primary" 
                        @bind-Checked="context.Item.Visible" />
                </EditTemplate>
            </PropertyColumn>
            <PropertyColumn Property="x => x.Description" Title="Description" IsEditable="true"/>
            <PropertyColumn Property="x => x.Price" Title="Price" IsEditable="true"/>
            <PropertyColumn 
                Property='x => string.Join(", ", x.AllowedUserGroups.Select(e => e.ToString()))' 
                Title="User groups" 
                IsEditable="true"> 
                <EditTemplate>
                    <MudSelect 
                        T="UserGroup" 
                        Label="Minimum user group"
                        @bind-Value="SelectedUserGroup">
                        @foreach (var group in Enum.GetValues<UserGroup>()) {
                                <MudSelectItem T="UserGroup" Value="@group">@group</MudSelectItem>
                            }
                    </MudSelect>
                </EditTemplate>
            </PropertyColumn>
            <PropertyColumn Property="x => x.NumberOfTickets" Title="NumberOfTickets" IsEditable="true"/>
            <TemplateColumn>
                <CellTemplate>
                    <MudIconButton
                        Size="@Size.Small" 
                        Icon="@Icons.Material.Outlined.Edit"
                        OnClick="@context.Actions.StartEditingItemAsync"/>
                </CellTemplate>
            </TemplateColumn>
        </Columns>
    </MudDataGrid>

    <MudToolBar>
        <MudSpacer />
        <MudButton
            Color="Color.Primary"
            Variant="Variant.Filled"
            EndIcon="@Icons.Material.Outlined.Add" 
            OnClick="@AddItem">
                Add Product
            </MudButton>
    </MudToolBar>
</MudPaper>
@code
{
    [Parameter]
    public System.Security.Claims.ClaimsPrincipal User { get; set; }

    private IEnumerable<ProductResponse> _products = new List<ProductResponse>();
    private UserGroup SelectedUserGroup { get; set; }

    private bool _loading = true;
    protected override async Task OnInitializedAsync()
    {
        var result = await ProductService.GetProducts();
        _loading = false;
        result.Match(
            Succ: products => {
                _products = products;
            },
            Fail: error => {
                Snackbar.Add(error.Message, Severity.Error);
            }
        );
    }

    void CanceledEditingItem(ProductResponse item)
    {
        Snackbar.Add("Cancelled product changes", Severity.Info);
    }

    async Task CommittedItemChanges(ProductResponse item)
    {
        if (item.Id == 0)
        {
            var result = ProductService.AddProduct(new AddProductRequest{
                Name = item.Name,
                Description = item.Description,
                NumberOfTickets = item.NumberOfTickets,
                Price = item.Price,
                Visible = true,
                AllowedUserGroups = Enum.GetValues<UserGroup>().Where(e => e >= SelectedUserGroup ).ToList()
            });

            await result.Match(
                Succ: async product =>
                {
                    // Succesfully added product
                    Snackbar.Add("Product added", Severity.Success);
                    
                    // Retrieve all items again in order to update id 
                    var retrieveItems = await ProductService.GetProducts();
                    retrieveItems.Match(
                        Succ: items => {
                            _products = items;
                        },
                        Fail: error => {
                            // Errors while re-retrieving items, non-fatal (just means _products are slightly outdated)
                            Snackbar.Add(error.Message, Severity.Warning);
                        }
                    );
                },
                Fail: error => {
                    Snackbar.Add(error.Message, Severity.Error);
                }
            );
        }
        else
        {
            var result = ProductService.UpdateProduct(new UpdateProductRequest{
                Id = item.Id,
                Name = item.Name,
                Description = item.Description,
                NumberOfTickets = item.NumberOfTickets,
                Price = item.Price,
                Visible = true,
                AllowedUserGroups = Enum.GetValues<UserGroup>().Where(e => e >= SelectedUserGroup ).ToList()
            });

            await result.Match(
                Succ: async result =>
                {
                    Snackbar.Add("Product updated", Severity.Success);

                    var retrieveItems = await ProductService.GetProducts();
                    retrieveItems.Match(
                        Succ: items => {
                            _products = items;
                        },
                        Fail: error => {
                            // Errors while re-retrieving items, non-fatal (just means _products are slightly outdated)
                            Snackbar.Add(error.Message, Severity.Warning);
                        }
                    );
                },
                Fail: error =>
                {
                    Snackbar.Add(error.Message, Severity.Warning);
                }
            );
        }
    }

    void AddItem()
    {
        _products = _products.Append<ProductResponse>(new ProductResponse{
            Id = 0,
            Name = "",
            Description = "",
            IsPerk = false,
            NumberOfTickets = 1,
            Price = 0,
            AllowedUserGroups = Enum.GetValues<UserGroup>()
        });
    }

    private Func<ProductResponse, int, string> _RowStyleFunc => (x, i) =>
    {
        if (!x.Visible)
        {
            return "background-color:#ebebeb;font-style:italic;font-color:#8a8686;";
        }
        return "";
    };
}